using System.Runtime.CompilerServices;
using Esprima.Ast;

namespace Esprima.Utils;

[AutoGeneratedAstVisitor]
public partial class AstVisitor
{
    private static Exception UnsupportedNodeType(Type nodeType, [CallerMemberName] string? callerName = null) =>
        new NotImplementedException($"The visitor does not support nodes of type {nodeType}. You can override {callerName} to handle this case.");

    public virtual object? Visit(Node node)
    {
        return node.Accept(this);
    }

    protected internal virtual object? VisitExportSpecifier(ExportSpecifier exportSpecifier)
    {
        Visit(exportSpecifier.Local);

        if (exportSpecifier.Exported != exportSpecifier.Local)
        {
            Visit(exportSpecifier.Exported);
        }

        return exportSpecifier;
    }

    protected internal virtual object? VisitExtension(Node node)
    {
        // Node type Extension is used to represent extensions to the standard AST (for example, see JSX parsing).
        // Nodes of this type never appear in the tree returned by the core parser (JavaScriptParser),
        // thus the visitor doesn't deal with this type by default. Inheritors either need to override this method,
        // or inherit from another visitor which was built to handle extension nodes (e.g. JsxAstVisitor in the case of JSX).

        throw UnsupportedNodeType(node.GetType());
    }

    protected internal virtual object? VisitImportSpecifier(ImportSpecifier importSpecifier)
    {
        if (importSpecifier.Imported != importSpecifier.Local)
        {
            Visit(importSpecifier.Imported);
        }

        Visit(importSpecifier.Local);

        return importSpecifier;
    }

    protected internal virtual object? VisitProperty(Property property)
    {
        if (!property.Shorthand)
        {
            Visit(property.Key);
        }

        Visit(property.Value);

        return property;
    }

    protected internal virtual object? VisitTemplateLiteral(TemplateLiteral templateLiteral)
    {
        ref readonly var quasis = ref templateLiteral.Quasis;
        ref readonly var expressions = ref templateLiteral.Expressions;

        TemplateElement quasi;
        for (var i = 0; !(quasi = quasis[i]).Tail; i++)
        {
            Visit(quasi);
            Visit(expressions[i]);
        }
        Visit(quasi);

        return templateLiteral;
    }
}
