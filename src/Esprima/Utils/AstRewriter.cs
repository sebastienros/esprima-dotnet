using System.Runtime.CompilerServices;
using Esprima.Ast;

namespace Esprima.Utils;

[AutoGeneratedAstVisitor]
public partial class AstRewriter : AstVisitor
{
    public virtual T VisitAndConvert<T>(T node, bool allowNull = false, [CallerMemberName] string? callerName = null)
        where T : Node?
    {
        if (node is null)
        {
            return allowNull ? null! : throw new ArgumentNullException(nameof(node));
        }

        return Visit(node) switch
        {
            T convertedNode => convertedNode,
            null when allowNull => null!,
            null => throw MustRewriteToSameNodeNonNullable(typeof(T), callerName),
            _ => throw (allowNull ? MustRewriteToSameNodeNullable(typeof(T), callerName) : MustRewriteToSameNodeNonNullable(typeof(T), callerName))
        };

        static Exception MustRewriteToSameNodeNonNullable(Type nodeType, string? callerName) =>
            new InvalidOperationException($"When called from {callerName}, rewriting a node of type {nodeType} must return a non-null value of the same type. Alternatively, override {callerName} and change it to not visit children of this type.");

        static Exception MustRewriteToSameNodeNullable(Type nodeType, string? callerName) =>
            new InvalidOperationException($"When called from {callerName}, rewriting a node of type {nodeType} must return null or a non-null value of the same type. Alternatively, override {callerName} and change it to not visit children of this type.");
    }

    public virtual bool VisitAndConvert<T>(in NodeList<T> nodes, out NodeList<T> newNodes, bool allowNullElement = false, [CallerMemberName] string? callerName = null)
        where T : Node?
    {
        List<T>? newNodeList = null;
        for (var i = 0; i < nodes.Count; i++)
        {
            var node = nodes[i];

            var newNode = VisitAndConvert(node, allowNull: allowNullElement, callerName);

            if (newNodeList is not null)
            {
                newNodeList.Add(newNode);
            }
            else if (newNode != node)
            {
                newNodeList = new List<T>();
                for (var j = 0; j < i; j++)
                {
                    newNodeList.Add(nodes[j]);
                }

                newNodeList.Add(newNode);
            }
        }

        if (newNodeList is not null)
        {
            newNodes = new NodeList<T>(newNodeList);
            return true;
        }

        newNodes = nodes;
        return false;
    }

    protected internal override object? VisitExportSpecifier(ExportSpecifier exportSpecifier)
    {
        Expression local;
        Expression exported;

        if (exportSpecifier.Exported == exportSpecifier.Local)
        {
            exported = local = VisitAndConvert(exportSpecifier.Local);
        }
        else
        {
            local = VisitAndConvert(exportSpecifier.Local);
            exported = VisitAndConvert(exportSpecifier.Exported);
        }

        return exportSpecifier.UpdateWith(local, exported);
    }

    protected internal override object? VisitImportSpecifier(ImportSpecifier importSpecifier)
    {
        Expression imported;
        Identifier local;

        if (importSpecifier.Imported == importSpecifier.Local)
        {
            imported = local = VisitAndConvert(importSpecifier.Local);
        }
        else
        {
            imported = VisitAndConvert(importSpecifier.Imported);
            local = VisitAndConvert(importSpecifier.Local);
        }

        return importSpecifier.UpdateWith(imported, local);
    }

    protected internal override object? VisitProperty(Property property)
    {
        Expression? key;
        Node value;

        if (property.Shorthand)
        {
            value = VisitAndConvert(property.Value);
            key = (value is AssignmentPattern assignmentPattern
                ? assignmentPattern.Left
                : value).As<Identifier>();
        }
        else
        {
            key = VisitAndConvert(property.Key);
            value = VisitAndConvert(property.Value);
        }

        return property.UpdateWith(key, value);
    }
}
