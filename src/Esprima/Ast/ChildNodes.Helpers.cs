namespace Esprima.Ast
{
    public readonly partial struct ChildNodes : IEnumerable<Node>
    {
        public partial struct Enumerator : IEnumerator<Node>
        {
            // This file declares helper methods for implementing Node.MoveNextChild. Only declarations are listed here because
            // the method bodies (finite state machines implementing the actual enumerations) are generated by a source generator
            // (see ChildNodesEnumerationHelpersGenerator in the Esprima.Esprima.SourceGenerators project).

            // Generation is done based on the method signatures. Methods must be partial and must return Node?.
            // The parameter list can only contain single nodes (Node) or node lists (in NodeList<T>). In the latter case
            // the method must be generic (as NodeList<T> is not covariant) and the generic constraint must be Node (e.g. where T : Node).
            // Nullability annotations can be used to specify if a node is optional (Node?) or a node list could contain null values (in NodeList<T?>).
            // (However, since nullability of reference types is not part of the method signature, we can't overload a single method name.)

            #region 1 argument

            internal partial Node? MoveNext(Node arg0);
            internal partial Node? MoveNext<T>(in NodeList<T> arg0) where T : Node;

            internal partial Node? MoveNextNullable(Node? arg0);
            internal partial Node? MoveNextNullable<T>(in NodeList<T?> arg0) where T : Node;

            #endregion

            #region 2 arguments

            internal partial Node? MoveNext(Node arg0, Node arg1);
            internal partial Node? MoveNext<T0>(in NodeList<T0> arg0, Node arg1) where T0 : Node;
            internal partial Node? MoveNext<T1>(Node arg0, in NodeList<T1> arg1) where T1 : Node;

            internal partial Node? MoveNextNullableAt0(Node? arg0, Node arg1);
            internal partial Node? MoveNextNullableAt0<T1>(Node? arg0, in NodeList<T1> arg1) where T1 : Node;

            internal partial Node? MoveNextNullableAt1(Node arg0, Node? arg1);

            #endregion

            #region 3 arguments

            internal partial Node? MoveNext(Node arg0, Node arg1, Node arg2);
            internal partial Node? MoveNext<T0, T2>(in NodeList<T0> arg0, Node arg1, in NodeList<T2> arg2)
                where T0 : Node
                where T2 : Node;
            internal partial Node? MoveNext<T2>(Node arg0, Node arg1, in NodeList<T2> arg2) where T2 : Node;

            internal partial Node? MoveNextNullableAt0<T1>(Node? arg0, in NodeList<T1> arg1, Node arg2) where T1 : Node;
            internal partial Node? MoveNextNullableAt0<T2>(Node? arg0, Node arg1, in NodeList<T2> arg2) where T2 : Node;

            internal partial Node? MoveNextNullableAt1<T2>(Node arg0, Node? arg1, in NodeList<T2> arg2) where T2 : Node;

            internal partial Node? MoveNextNullableAt1_2(Node arg0, Node? arg1, Node? arg2);

            internal partial Node? MoveNextNullableAt2(Node arg0, Node arg1, Node? arg2);
            internal partial Node? MoveNextNullableAt2<T1>(Node arg0, in NodeList<T1> arg1, Node? arg2) where T1 : Node;

            #endregion

            #region 4 arguments

            internal partial Node? MoveNextNullableAt0_1_2(Node? arg0, Node? arg1, Node? arg2, Node arg3);

            internal partial Node? MoveNextNullableAt0_1<T3>(Node? arg0, Node? arg1, Node arg2, in NodeList<T3> arg3) where T3 : Node;

            internal partial Node? MoveNextNullableAt0_2<T1, T3>(Node? arg0, in NodeList<T1> arg1, Node? arg2, in NodeList<T3> arg3)
                where T1 : Node
                where T3 : Node;

            #endregion

            #region Special enumerations

            internal Node? MoveNextTemplateLiteral(in NodeList<TemplateElement> quasis, in NodeList<Expression> expressions)
            {
                // Equivalent to:

                // TemplateElement quasi;
                // for (var i = 0; !(quasi = Quasis[i]).Tail; i++)
                // {
                //     yield return quasi;
                //     yield return Expressions[i];
                // }
                // yield return quasi;

                switch (_propertyIndex)
                {
                    case 0:
                        _propertyIndex++;

                        var quasi = quasis[_listIndex];
                        if (quasi.Tail)
                        {
                            _propertyIndex++;
                            _listIndex = 0;
                        }

                        return quasi;
                    case 1:
                        _propertyIndex--;

                        return expressions[_listIndex++];
                    default:
                        return null;
                }
            }

            #endregion
        }
    }
}
